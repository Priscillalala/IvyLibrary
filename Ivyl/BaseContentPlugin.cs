using RoR2;
using RoR2.ContentManagement;
using System.Collections;
using BepInEx;
using System.Runtime.CompilerServices;
using System;
using HG.Coroutines;
using HG;

namespace IvyLibrary
{
    public interface ILoadStaticContentAsyncArgs
    {
        IProgress<float> progressReceiver { get; set; }
        ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
        ContentPack content { get; set; }
    }

    public interface IGetContentPackAsyncArgs
    {
        IProgress<float> progressReceiver { get; set; }
        ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
        ContentPack output { get; set; }
        int retriesRemaining { get; set; }
    }

    public interface IFinalizeAsyncArgs
    {
        IProgress<float> progressReceiver { get;  set; }
        ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
        ReadOnlyContentPack finalContentPack { get; set; }
    }

    public class BaseContentPlugin : BaseContentPlugin<BaseContentPlugin.LoadStaticContentAsyncArgs, BaseContentPlugin.GetContentPackAsyncArgs, BaseContentPlugin.FinalizeAsyncArgs> 
    {
        public struct LoadStaticContentAsyncArgs : ILoadStaticContentAsyncArgs, IProgress<float>
        {
            public IProgress<float> progressReceiver { get; set; }
            public ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
            public ContentPack content { get; set; }

            public void Report(float progress) => progressReceiver.Report(progress);
        }

        public struct GetContentPackAsyncArgs : IGetContentPackAsyncArgs, IProgress<float>
        {
            public IProgress<float> progressReceiver { get; set; }
            public ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
            public ContentPack output { get; set; }
            public int retriesRemaining { get; set; }

            public void Report(float progress) => progressReceiver.Report(progress);
        }

        public struct FinalizeAsyncArgs : IFinalizeAsyncArgs, IProgress<float>
        {
            public IProgress<float> progressReceiver { get; set; }
            public ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos { get; set; }
            public ReadOnlyContentPack finalContentPack { get; set; }

            public void Report(float progress) => progressReceiver.Report(progress);
        }
    }

    /// <summary>
    /// A specialized <see cref="BaseUnityPlugin"/> that generates a <see cref="ContentPack"/> and implements <see cref="IContentPackProvider"/>; comparable to <see cref="RoR2Content"/>.
    /// </summary>
    public abstract class BaseContentPlugin<TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs> : BaseUnityPlugin, IContentPackProvider
        where TLoadStaticContentAsyncArgs : struct, ILoadStaticContentAsyncArgs
        where TGetContentPackAsyncArgs : struct, IGetContentPackAsyncArgs
        where TFinalizeAsyncArgs : struct, IFinalizeAsyncArgs
    {
        /// <summary>
        /// A <see cref="ContentPack"/> generated by this plugin.
        /// </summary>
        public ContentPack Content { get; }

        string IContentPackProvider.identifier => Info.Metadata.GUID;

        public delegate IEnumerator LoadStaticContentAsyncDelegate(TLoadStaticContentAsyncArgs args);
        public delegate IEnumerator GenerateContentPackAsyncDelegate(TGetContentPackAsyncArgs args);
        public delegate IEnumerator FinalizeAsyncDelegate(TFinalizeAsyncArgs args);

        /// <summary>
        /// Subscribers are yielded in parallel during <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        public event LoadStaticContentAsyncDelegate loadStaticContentAsync;
        /// <summary>
        /// Subscribers are yielded in parallel during <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        public event GenerateContentPackAsyncDelegate generateContentPackAsync;
        /// <summary>
        /// Subscribers are yielded in parallel during <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        public event FinalizeAsyncDelegate finalizeAsync;

        public BaseContentPlugin() : base()
        {
            Content = new ContentPack
            {
                identifier = ((IContentPackProvider)this).identifier
            };
            ContentManager.collectContentPackProviders += add => add(this);
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="loadStaticContentAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator LoadStaticContentAsync(TLoadStaticContentAsyncArgs args)
        {
            if (loadStaticContentAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine(args.progressReceiver);
                foreach (LoadStaticContentAsyncDelegate func in loadStaticContentAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        ReadableProgress<float> readableProgress = new ReadableProgress<float>();
                        parallelProgressCoroutine.Add(
                            func(args with { progressReceiver = readableProgress }),
                            readableProgress);
                    }
                }
                while (parallelProgressCoroutine.MoveNext())
                {
                    yield return parallelProgressCoroutine.Current;
                }
                loadStaticContentAsync = null;
            }
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="generateContentPackAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>, then outputs <see cref="Content"/>. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator GenerateContentPackAsync(TGetContentPackAsyncArgs args)
        {
            ContentPack.Copy(Content, args.output);
            if (generateContentPackAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine(args.progressReceiver);
                foreach (GenerateContentPackAsyncDelegate func in generateContentPackAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        ReadableProgress<float> readableProgress = new ReadableProgress<float>();
                        parallelProgressCoroutine.Add(
                            func(args with { progressReceiver = readableProgress }),
                            readableProgress);
                    }
                }
                while (parallelProgressCoroutine.MoveNext())
                {
                    yield return parallelProgressCoroutine.Current;
                }
            }
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="finalizeAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>, then populates the asset ids of networked objects in <see cref="Content"/>. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator FinalizeAsync(TFinalizeAsyncArgs args)
        {
            generateContentPackAsync = null;
            if (finalizeAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine(args.progressReceiver);
                foreach (FinalizeAsyncDelegate func in finalizeAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        ReadableProgress<float> readableProgress = new ReadableProgress<float>();
                        parallelProgressCoroutine.Add(
                            func(args with { progressReceiver = readableProgress }),
                            readableProgress);
                    }
                }
                while (parallelProgressCoroutine.MoveNext())
                {
                    yield return parallelProgressCoroutine.Current;
                }
                finalizeAsync = null;
            }
            Content.PopulateNetworkedObjectAssetIds();
        }

        IEnumerator IContentPackProvider.LoadStaticContentAsync(RoR2.ContentManagement.LoadStaticContentAsyncArgs args) => LoadStaticContentAsync(new TLoadStaticContentAsyncArgs 
        {
            progressReceiver = args.progressReceiver,
            peerLoadInfos = args.peerLoadInfos,
            content = Content,
        });

        IEnumerator IContentPackProvider.GenerateContentPackAsync(RoR2.ContentManagement.GetContentPackAsyncArgs args) => GenerateContentPackAsync(new TGetContentPackAsyncArgs 
        {
            progressReceiver = args.progressReceiver,
            peerLoadInfos = args.peerLoadInfos,
            output = args.output,
            retriesRemaining = args.retriesRemaining,
        });

        IEnumerator IContentPackProvider.FinalizeAsync(RoR2.ContentManagement.FinalizeAsyncArgs args) => FinalizeAsync(new TFinalizeAsyncArgs 
        {
            progressReceiver = args.progressReceiver,
            peerLoadInfos = args.peerLoadInfos,
            finalContentPack = args.finalContentPack,
        });
    }
}