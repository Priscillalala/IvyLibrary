using RoR2;
using RoR2.ContentManagement;
using System.Collections;
using BepInEx;
using System.Runtime.CompilerServices;
using System;

namespace IvyLibrary
{
    /// <summary>
    /// A specialized <see cref="BaseUnityPlugin"/> that generates a <see cref="ContentPack"/> implements <see cref="IContentPackProvider"/>; comparable to <see cref="RoR2Content"/>.
    /// </summary>
    public abstract class BaseContentPlugin : BaseUnityPlugin, IContentPackProvider
    {
        /// <summary>
        /// A <see cref="ContentPack"/> generated by this plugin.
        /// </summary>
        public ContentPack Content { get; }

        string IContentPackProvider.identifier => Info.Metadata.GUID;

        public delegate IEnumerator LoadStaticContentAsyncDelegate(LoadStaticContentAsyncArgs args);
        public delegate IEnumerator GenerateContentPackAsyncDelegate(GetContentPackAsyncArgs args);
        public delegate IEnumerator FinalizeAsyncDelegate(FinalizeAsyncArgs args);

        /// <summary>
        /// Subscribers are yielded in order during <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        public event LoadStaticContentAsyncDelegate loadStaticContentAsync;
        /// <summary>
        /// Subscribers are yielded in order during <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        public event GenerateContentPackAsyncDelegate generateContentPackAsync;
        /// <summary>
        /// Subscribers are yielded in order during <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        public event FinalizeAsyncDelegate finalizeAsync;

        public BaseContentPlugin() : base()
        {
            Content = new ContentPack
            {
                identifier = ((IContentPackProvider)this).identifier
            };
            ContentManager.collectContentPackProviders += add => add(this);
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="loadStaticContentAsync"/> and reports progress for each subscriber. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator LoadStaticContentAsyncImpl(LoadStaticContentAsyncArgs args)
        {
            if (loadStaticContentAsync != null)
            {
                Delegate[] invocationList = loadStaticContentAsync.GetInvocationList();
                int length = invocationList.Length;
                for (int i = 0; i < length; i++)
                {
                    yield return ((LoadStaticContentAsyncDelegate)invocationList[i])?.Invoke(args);
                    args.ReportProgress((float)(i + 1) / length);
                }
                loadStaticContentAsync = null;
            }
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="generateContentPackAsync"/> and reports progress for each subscriber, then outputs <see cref="Content"/>. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator GenerateContentPackAsyncImpl(GetContentPackAsyncArgs args)
        {
            if (generateContentPackAsync != null)
            {
                Delegate[] invocationList = generateContentPackAsync.GetInvocationList();
                int length = invocationList.Length;
                for (int i = 0; i < length; i++)
                {
                    yield return ((GenerateContentPackAsyncDelegate)invocationList[i])?.Invoke(args);
                    args.ReportProgress((float)(i + 1) / length);
                }
            }
            ContentPack.Copy(Content, args.output);
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="finalizeAsync"/> and reports progress for each subscriber, then populates the asset ids of networked objects. This behavior can be overridden.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected virtual IEnumerator FinalizeAsyncImpl(FinalizeAsyncArgs args)
        {
            generateContentPackAsync = null;
            if (finalizeAsync != null)
            {
                Delegate[] invocationList = finalizeAsync.GetInvocationList();
                int length = invocationList.Length;
                for (int i = 0; i < length; i++)
                {
                    yield return ((FinalizeAsyncDelegate)invocationList[i])?.Invoke(args);
                    args.ReportProgress((float)(i + 1) / length);
                }
                finalizeAsync = null;
            }
            Content.PopulateNetworkedObjectAssetIds();
        }

        IEnumerator IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs args) => LoadStaticContentAsyncImpl(args);

        IEnumerator IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs args) => GenerateContentPackAsyncImpl(args);

        IEnumerator IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs args) => FinalizeAsyncImpl(args);
    }
}