using RoR2;
using RoR2.ContentManagement;
using System.Collections;
using BepInEx;
using System.Runtime.CompilerServices;
using System;
using HG.Coroutines;
using HG;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

namespace IvyLibrary
{
    /// <summary>
    /// A specialized <see cref="BaseUnityPlugin"/> that generates a <see cref="ContentPack"/> and implements <see cref="IContentPackProvider"/>; comparable to <see cref="RoR2Content"/>.
    /// </summary>
    public abstract class BaseContentPlugin : BaseContentPlugin<BaseContentPlugin.LoadStaticContentAsyncArgs, BaseContentPlugin.GetContentPackAsyncArgs, BaseContentPlugin.FinalizeAsyncArgs> 
    {
        /// <summary>
        /// A specialized version of <see cref="RoR2.ContentManagement.LoadStaticContentAsyncArgs"/> for use with <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </summary>
        /// <remarks>
        /// Inherit from this class to define custom args for a <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </remarks>
        public class LoadStaticContentAsyncArgs : RoR2.ContentManagement.LoadStaticContentAsyncArgs
        {
            public LoadStaticContentAsyncArgs() 
                : base(default, default)
            { }

            [EditorBrowsable(EditorBrowsableState.Never)]
            [Obsolete("Progress should be directly reported by the coroutine instead.")]
            public new IProgress<float> progressReceiver => base.progressReceiver;
            public new ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos => base.peerLoadInfos;
            public ContentPack content { get; init; }
        }

        /// <summary>
        /// A specialized version of <see cref="RoR2.ContentManagement.GetContentPackAsyncArgs"/> for use with <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </summary>
        /// <remarks>
        /// Inherit from this class to define custom args for a <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </remarks>
        public class GetContentPackAsyncArgs : RoR2.ContentManagement.GetContentPackAsyncArgs
        {
            public GetContentPackAsyncArgs() 
                : base(default, default, default, default)
            { }

            [EditorBrowsable(EditorBrowsableState.Never)]
            [Obsolete("Progress should be directly reported by the coroutine instead.")]
            public new IProgress<float> progressReceiver => base.progressReceiver;
            public new ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos => base.peerLoadInfos;
            public new ContentPack output => base.output;
            public new int retriesRemaining => base.retriesRemaining;
        }

        /// <summary>
        /// A specialized version of <see cref="RoR2.ContentManagement.FinalizeAsyncArgs"/> for use with <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </summary>
        /// <remarks>
        /// Inherit from this class to define custom args for a <see cref="BaseContentPlugin{TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs}"/>.
        /// </remarks>
        public class FinalizeAsyncArgs : RoR2.ContentManagement.FinalizeAsyncArgs
        {
            public FinalizeAsyncArgs() 
                : base(default, default, default)
            { }

            [EditorBrowsable(EditorBrowsableState.Never)]
            [Obsolete("Progress should be directly reported by the coroutine instead.")]
            public new IProgress<float> progressReceiver => base.progressReceiver;
            public new ReadOnlyArray<ContentPackLoadInfo> peerLoadInfos => base.peerLoadInfos;
            public new ReadOnlyContentPack finalContentPack => base.finalContentPack;
        }
    }

    /// <inheritdoc cref="BaseContentPlugin"/>
    /// <typeparam name="TLoadStaticContentAsyncArgs">Custom <see cref="BaseContentPlugin.LoadStaticContentAsyncArgs"/>.</typeparam>
    /// <typeparam name="TGetContentPackAsyncArgs">Custom <see cref="BaseContentPlugin.GetContentPackAsyncArgs"/>.</typeparam>
    /// <typeparam name="TFinalizeAsyncArgs">Custom <see cref="BaseContentPlugin.FinalizeAsyncArgs"/>.</typeparam>
    public abstract class BaseContentPlugin<TLoadStaticContentAsyncArgs, TGetContentPackAsyncArgs, TFinalizeAsyncArgs> : BaseUnityPlugin, IContentPackProvider
        where TLoadStaticContentAsyncArgs : BaseContentPlugin.LoadStaticContentAsyncArgs, new()
        where TGetContentPackAsyncArgs : BaseContentPlugin.GetContentPackAsyncArgs, new()
        where TFinalizeAsyncArgs : BaseContentPlugin.FinalizeAsyncArgs, new()
    {
        /// <summary>
        /// A <see cref="ContentPack"/> generated by this plugin.
        /// </summary>
        public ContentPack Content { get; }

        string IContentPackProvider.identifier => Info.Metadata.GUID;

        public delegate IEnumerator<float> LoadStaticContentAsyncDelegate(TLoadStaticContentAsyncArgs args);
        public delegate IEnumerator<float> GenerateContentPackAsyncDelegate(TGetContentPackAsyncArgs args);
        public delegate IEnumerator<float> FinalizeAsyncDelegate(TFinalizeAsyncArgs args);

        /// <summary>
        /// Subscribers are progressed in parallel during <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        public event LoadStaticContentAsyncDelegate loadStaticContentAsync;
        /// <summary>
        /// Subscribers are progressed in parallel during <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        public event GenerateContentPackAsyncDelegate generateContentPackAsync;
        /// <summary>
        /// Subscribers are progressed in parallel during <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        public event FinalizeAsyncDelegate finalizeAsync;

        public BaseContentPlugin() : base()
        {
            Content = new ContentPack
            {
                identifier = ((IContentPackProvider)this).identifier
            };
            ContentManager.collectContentPackProviders += add => add(this);
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation invokes <see cref="loadStaticContentAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>. This behavior can be overridden.
        /// </remarks>
        /// <returns>An <see cref="IEnumerator{T}"/> of type <see cref="float"/> where <see cref="IEnumerator{T}.Current"/> represents the current progress of the operation from <c>0f</c> to <c>1f</c>.</returns>
        protected virtual IEnumerator<float> LoadStaticContentAsync(TLoadStaticContentAsyncArgs args)
        {
            if (loadStaticContentAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine();
                foreach (LoadStaticContentAsyncDelegate func in loadStaticContentAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        parallelProgressCoroutine.Add(func(args));
                    }
                }
                return parallelProgressCoroutine;
            }
            return Enumerable.Empty<float>().GetEnumerator();
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation copies <see cref="Content"/> to <see cref="GetContentPackAsyncArgs.output"/>, then invokes <see cref="generateContentPackAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>. This behavior can be overridden.
        /// </remarks>
        /// <returns>An <see cref="IEnumerator{T}"/> of type <see cref="float"/> where <see cref="IEnumerator{T}.Current"/> represents the current progress of the operation from <c>0f</c> to <c>1f</c>.</returns>
        protected virtual IEnumerator<float> GenerateContentPackAsync(TGetContentPackAsyncArgs args)
        {
            ContentPack.Copy(Content, args.output);
            if (generateContentPackAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine();
                foreach (GenerateContentPackAsyncDelegate func in generateContentPackAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        parallelProgressCoroutine.Add(func(args));
                    }
                }
                return parallelProgressCoroutine;
            }
            return Enumerable.Empty<float>().GetEnumerator();
        }

        /// <summary>
        /// Implementation of <see cref="IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs)"/>.
        /// </summary>
        /// <remarks>
        /// The default implementation populates the asset ids of networked objects in <see cref="Content"/>, then invokes <see cref="finalizeAsync"/> and tracks the results as a <see cref="ParallelProgressCoroutine"/>. This behavior can be overridden.
        /// </remarks>
        /// <returns>An <see cref="IEnumerator{T}"/> of type <see cref="float"/> where <see cref="IEnumerator{T}.Current"/> represents the current progress of the operation from <c>0f</c> to <c>1f</c>.</returns>
        protected virtual IEnumerator<float> FinalizeAsync(TFinalizeAsyncArgs args)
        {
            Content.PopulateNetworkedObjectAssetIds();
            if (finalizeAsync != null)
            {
                ParallelProgressCoroutine parallelProgressCoroutine = new ParallelProgressCoroutine();
                foreach (FinalizeAsyncDelegate func in finalizeAsync.GetInvocationList())
                {
                    if (func != null)
                    {
                        parallelProgressCoroutine.Add(func(args));
                    }
                }
                return parallelProgressCoroutine;
            }
            return Enumerable.Empty<float>().GetEnumerator();
        }

        IEnumerator IContentPackProvider.LoadStaticContentAsync(LoadStaticContentAsyncArgs args) 
        {
            TLoadStaticContentAsyncArgs customArgs = new TLoadStaticContentAsyncArgs
            {
                content = Content
            };
            args.Copy(customArgs);
            IEnumerator<float> loadStaticContentAsyncCoroutine = LoadStaticContentAsync(customArgs);
            while (loadStaticContentAsyncCoroutine.MoveNext())
            {
                args.ReportProgress(loadStaticContentAsyncCoroutine.Current);
                yield return ((IEnumerator)loadStaticContentAsyncCoroutine).Current;
            }
        } 

        IEnumerator IContentPackProvider.GenerateContentPackAsync(GetContentPackAsyncArgs args)
        {
            TGetContentPackAsyncArgs customArgs = new TGetContentPackAsyncArgs();
            args.Copy(customArgs);
            IEnumerator<float> generateContentPackAsyncCoroutine = GenerateContentPackAsync(customArgs);
            while (generateContentPackAsyncCoroutine.MoveNext())
            {
                args.ReportProgress(generateContentPackAsyncCoroutine.Current);
                yield return ((IEnumerator)generateContentPackAsyncCoroutine).Current;
            }
        }

        IEnumerator IContentPackProvider.FinalizeAsync(FinalizeAsyncArgs args)
        {
            TFinalizeAsyncArgs customArgs = new TFinalizeAsyncArgs();
            args.Copy(customArgs);
            IEnumerator<float> finalizeAsyncCoroutine = FinalizeAsync(customArgs);
            while (finalizeAsyncCoroutine.MoveNext())
            {
                args.ReportProgress(finalizeAsyncCoroutine.Current);
                yield return ((IEnumerator)finalizeAsyncCoroutine).Current;
            }
            loadStaticContentAsync = null;
            generateContentPackAsync = null;
            finalizeAsync = null;
        }
    }
}